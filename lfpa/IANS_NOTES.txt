Need to understand this better!

Q0. What is the descriptor_queue for?

A: Looks to be the head of a free linked list of
descriptors. See the Descriptor life cycle below.

Q1. When do superblocks migrate from heap to heap?

A: See the SuperBlock life cycle below. It can/does happen.

Q2. How does the descriptor queue work, and why is the
implementation partial?


Q3. Why Partial slots in both sizeclass and procheap, and what
are they used for, and how do they relate to the descriptor_queue?

heap->Partial  is *directly* updated by:

	    RemoveEmptyDesc
	    HeapGetPartial
	    HeapPutPartial

sc->Partial is *directly* updated by:

	    ListRemoveEmptyDesc  (not implemented)
	    ListGetPartial
	    ListPutPartial

Note that the main differences b/w these two is that

heap->Partial

is a thread local slot of type descriptor*, while

sc->Partial

is a global linked list of type lf_fifo_queue_t.

Q4. What is the Next slot of a descriptor used for?

It is the pointer used to maintain the global descriptor_list
linked list. See the life cycle of descriptors.


= Overview =

=== Structures ==

- an anchor stores the "fullness" of a superblock:
     * avail
     * count
     * state
     * tag    (for the aba problem)

- a descriptor stores the global state of a superblock
     * a slot used in the lf_fifo_queue implementation
     * anchor
     * Next (a pointer to the "Next" superblock)
     * sb   (the actual superblock)
     * heap (the heap that owns the superblock)
     * sz   (the size of the blocks in the superblock)
     * maxcount  (the total number of block in the superblock)

- an active is a pointer to the descriptor of the superblock.
  they are aligned on 8 byte boundaries, so the lower 8 bytes
  are used to carve out:
     * credits (one less that the lower bound on the available blocks in the
       superblock)
     * ptr the "upper" 58 bits of the word. i.e. the descriptor*.

- a procheap is a thread local heap structure.
     * active
     * Partial  (a descriptor list ??)
     * sc  (a pointer to sizeclass, the parent size class)

- a sizeclass
     * Partial (a descriptor list ??)
     * sz (the blocksize)
     * sbsize (the superblock size)


= Life Cycle of SuperBlocks =

A super block starts out life being allocated and installed as the
active super block on a procheap by MallocFromNewSB. It remains there
until it becomes full, when it is set free (i.e. removed from the
active slot and not placed any where).

Thus free must be responsible for putting it back into play when
blocks are freed.

When a block is freed, and the superblock it belongs to was FULL,
(and thus becomes PARTIAL) the free routine calls:

     HeapPutPartial(desc);

which installs it as desc->heap->Partial, moving the old value to
the front of the desc->heap->sc->Partial linked list.

When MallocFromPartial gets a request, and heap->Partial is not
NULL, it tries to service the request from that superblock, if it
succeeds and the superblock is not FULL as a result, it tries to
install it as the active superblock of heap (this is not guaranteed
to succeed). If heap->Partial is NULL it also tries much the same
thing for the first superblock in the heap->sc->Partial linked list.

So from the looks of this we can get migration when heap->Partial is
NULL, since we just grab a superblock from the sizeclass list.


= Life Cycle of Descriptors =

When a new super block is allocated (MallocFromNewSB) a new descriptor
is required to manage the new super block. The routine that does this
is DescAlloc.

When (or if) the super block is returned to the OS in the course of a
free, RemoveEmptyDesc is called. At other times in a descriptor's life
cycle it is recycled using DescRetire. We will look into this in more
detail shortly. First we want to point out the follow sentences on
page 8:

"In the current implementation, superblock descriptors are not reused
as regular blocks and cannot be returned to the OS. This is acceptable
as descriptors constitute on average less than 1% of allocated
memory."

Descriptors are allocated in blocks of 1024 descriptors. They
are organized into linked lists using the Next pointer of
the descriptor struct. The descriptor_queue is used to maintain
a handle on this list of avaliable descriptors. DescAlloc
maintains this queue (the global queue_head). It is called
when a new super block is created. If the newly created
super block does not successfully get installed as the active
super block of the heap, the super block is munmapped and
the newly allocated descriptor is recycled using DescRetire.
DescRetire(desc) is a lock-free push of desc onto the front
of the queue_head.


So lets look at the other places where descriptors get recycled.

We loose the race in MallocFromNewSB we just call DescRetire.

In a free we call RemoveEmptyDesc(desc). This checks to
see if desc is the heap's current Partial. If it
is it replaces it by NULL and calls DescRetire(desc).
If it is not the heap's current Partial it calls

ListRemoveEmptyDesc(heap->sc);

Which to me makes no sense, since desc is not even involved in this
call. Maged must say something sensible here, surely. Nope. The
psuedo-code is identical:

RemoveEmptyDesc(heap,desc) {
  if CAS(&heap->Partial, desc, NULL)
    DescRetire(desc);
  else ListRemoveEmptyDesc(heap->sc);
  }

Hmmmmm.

In the MallocFromPartial we repeated call HeapGetPartial trying
to get a super block to service our request. If we come across
an empty superblock we retire it's descriptor, but not munmap
it's sb. Also Hmmmmm.


Maged say (about ListRemoveEmpty) The goal of the latter is to ensure
that empty descriptors are eventually made available for reuse, and
not necessarily to remove a specific empty descriptor immediately.


Random Notes:

-- lf_fifo_queue looks to my untrained eye to be a lifo not a fifo.



= Any Other Life Cyles? =

Nyet. But the fact that, apart from the client mmapped regions, only
two types on blocks are allocated, descriptor blocks and super blocks,
means we could base this allocator on top of a specialized version of
itself, which would prevent much fragmentation.

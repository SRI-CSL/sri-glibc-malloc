= Overview =

=== Structures ==

- an anchor stores the "fullness" of a superblock:
     * avail
     * count
     * state
     * tag    (for the aba problem)

- a descriptor stores the global state of a superblock
     * a slot used in the lf_fifo_queue implementation
     * anchor
     * Next (a pointer to the "Next" superblock)
     * sb   (the actual superblock)
     * heap (the heap that owns the superblock)
     * sz   (the size of the blocks in the superblock)
     * maxcount  (the total number of block in the superblock)

- an active is a pointer to the descriptor of the superblock.
  they are aligned on 8 byte boundaries, so the lower 8 bytes
  are used to carve out:
     * credits (one less that the lower bound on the available blocks in the
       superblock)
     * ptr the "upper" 58 bits of the word. i.e. the descriptor*.

- a procheap is a thread local heap structure.
     * active
     * Partial  (a single descriptor)
     * sc  (a pointer to sizeclass, the parent size class)

- a sizeclass
     * Partial (a descriptor list/queue )
     * sz (the blocksize)
     * sbsize (the superblock size)


= Life Cycle of SuperBlocks =

A super block starts out life being allocated and installed as the
active super block on a procheap by MallocFromNewSB. It remains there
until it becomes full, when it is set free (i.e. removed from the
active slot and not placed any where).

Thus free must be responsible for putting it back into play when
blocks are freed.

When a block is freed, and the superblock it belongs to was FULL,
(and thus becomes PARTIAL) the free routine calls:

     HeapPutPartial(desc);

which installs it as desc->heap->Partial, moving the old value to
the front of the desc->heap->sc->Partial linked list.

When MallocFromPartial gets a request, and heap->Partial is not
NULL, it tries to service the request from that superblock, if it
succeeds and the superblock is not FULL as a result, it tries to
install it as the active superblock of heap (this is not guaranteed
to succeed). If heap->Partial is NULL it also tries much the same
thing for the first superblock in the heap->sc->Partial linked list.

So from the looks of this we can get migration when heap->Partial is
NULL, since we just grab a superblock from the sizeclass list.


= Life Cycle of Descriptors =

When a new super block is allocated (MallocFromNewSB) a new descriptor
is required to manage the new super block. The routine that does this
is DescAlloc.

When (or if) the super block is returned to the OS in the course of a
free, RemoveEmptyDesc is called. At other times in a descriptor's life
cycle it is recycled using DescRetire. We will look into this in more
detail shortly. First we want to point out the follow sentences on
page 8:

"In the current implementation, superblock descriptors are not reused
as regular blocks and cannot be returned to the OS. This is acceptable
as descriptors constitute on average less than 1% of allocated
memory."

Descriptors are allocated in blocks of 1024 descriptors. They
are organized into linked lists using the Next pointer of
the descriptor struct. The descriptor_queue is used to maintain
a handle on this list of avaliable descriptors. DescAlloc
maintains this queue (the global queue_head). It is called
when a new super block is created. If the newly created
super block does not successfully get installed as the active
super block of the heap, the super block is munmapped and
the newly allocated descriptor is recycled using DescRetire.
DescRetire(desc) is a lock-free push of desc onto the front
of the queue_head.


So lets look at the other places where descriptors get recycled.

We loose the race in MallocFromNewSB we just call DescRetire.

In a free call if the desc becomes EMPTY, then we call
RemoveEmptyDesc(desc). This checks to see if desc is the heap's
current Partial. If it is it replaces it by NULL and calls
DescRetire(desc).  If it is not the heap's current Partial it
just calls

ListRemoveEmptyDesc(heap->sc);

Which to me makes no sense, since desc is not even involved in this
call. Maged must say something sensible here, surely. Nope. The
psuedo-code is identical:

RemoveEmptyDesc(heap,desc) {
  if CAS(&heap->Partial, desc, NULL)
    DescRetire(desc);
  else ListRemoveEmptyDesc(heap->sc);
  }

Hmmmmm.  I'm still not clear on the case when is a free:

the desc becomes EMPTY, but it is not heap->Partial. It looks
to me like it just gets lost.


In the MallocFromPartial we repeated call HeapGetPartial trying
to get a super block to service our request. If we come across
an empty superblock we retire it's descriptor, but not munmap
it's sb. Also Hmmmmm.


Maged say (about ListRemoveEmpty) The goal of the latter is to ensure
that empty descriptors are eventually made available for reuse, and
not necessarily to remove a specific empty descriptor immediately.


Random Notes:

-- lf_fifo_queue looks to my untrained eye to be a lifo not a fifo.


= Any Other Life Cyles? =

Nyet. But the fact that, apart from the client mmapped regions, only
two types on blocks are allocated, descriptor blocks and super blocks,
means we could base this allocator on top of a specialized version of
itself, which would prevent much fragmentation.

= Questions that Pop into my Head = 

Q0.[X] What is the descriptor_queue for?

A: Looks to be the head of a free linked list of
descriptors. See the Descriptor life cycle below.

Q1.[X] When do superblocks migrate from heap to heap?

A: See the SuperBlock life cycle below. It does appear to
be possible.

Q2.[X] How does the descriptor queue work, and why is the
implementation partial?

A: It is used as a pool of "empty" descriptors. I think I have fixed
the partial implementation. Note that the current implmentation
of lf_fifo_queue is in fact a LIFO queue, and is *not* Maged's
prefered solution, which is a FIFO queue.

Q3.[X] Why Partial slots in both sizeclass and procheap, and what
are they used for, and how do they relate to the descriptor_queue?

A. The sizeclass Partial is a list of descriptors, the heap is
a handle on the "current" partial descriptor. I.e. 

heap->Partial

is a *thread* local slot of type descriptor*, while

sc->Partial

is a global linked list of type lf_fifo_queue_t.

heap->Partial  is *directly* updated by:

	    free calling RemoveEmptyDesc(desc): If heap->Partial is
	    desc, it tries to replace it with NULL.

	    MallocFromPartial calling HeapGetPartial(heap): if NULL installs
	    a sb from heap->sc if there is one

	    free & MallocFromActive calling HeapPutPartial(desc) :
	    pushes the current heap->Partial onto heap->sc->Partial
	    and replaces it with desc.

sc->Partial is *directly* updated by:

	    ListRemoveEmptyDesc
	    ListGetPartial
	    ListPutPartial

Q4.[X] What is the Next slot of a descriptor used for?

A. It is the pointer used to maintain the global free descriptor_list
linked list. See the life cycle of descriptors.

Q5.[X] Does heap->Partial store the most recent super block
that this thread freed a block to, or is updated more or less
frequently?

A. Looks to be a bit more complicated than this. Since it can get
updated from free, MallocFromActive, and MallocFromPartial.

Q6.[?] If desc is heap->Partial does this mean desc->heap = heap?

A.[?] When a desc is first allocated it's desc->heap slot is the heap that
created it. The only place this slot changes is in the
MallocFromPartial routine, where it is updated to the to the heap that
got it from a call to HeapGetPartial(heap).


Q7. Are there repetitions in the sc->Partial queue?

Q8.[?] I am not really sure why descriptors cannot be returned back to
the OS in principle. Is it more than just a lack of infrastructure to
do this?

A.[?] This might be because the FIFO queue algorithm in Michael & Scott
can't release the nodes back to the OS, since these nodes are descriptors
I think we have our answer. Not that after Maged's pool allocator paper
came out, he subsequently "fixed" thsi problem with his hazard pointer
paper.







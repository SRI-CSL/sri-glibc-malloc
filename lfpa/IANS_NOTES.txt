Need to understand this better!

Q0. What is the descriptor_queue for?

Q1. When do superblocks migrate from heap to heap?

A: See the life cycle below. It can/does happen.

Q2. How does the descriptor queue work, and why is the
implementation partial?


Q3. Why Partial slots in both sizeclass and procheap, and what
are they used for, and how do they relate to the descriptor_queue?

heap->Partial  is *directly* updated by:

	    RemoveEmptyDesc
	    HeapGetPartial
	    HeapPutPartial

sc->Partial is *directly* updated by:

	    ListRemoveEmptyDesc  (not implemented)
	    ListGetPartial
	    ListPutPartial
	    

Q4. What is the Next slot of a descriptor used for?

It is the pointer used to maintain the global descriptor_list
linked list. See the life cycle of descriptors.


= Overview =

=== Structures ==

- an anchor stores the "fullness" of a superblock:
     * avail
     * count
     * state
     * tag    (for the aba problem)

- a descriptor stores the global state of a superblock
     * anchor
     * Next (a pointer to the "Next" superblock)
     * sb   (the actual superblock)
     * heap (the heap that owns the superblock)
     * sz   (the size of the blocks in the superblock)
     * maxcount  (the total number of block in the superblock)

- an active is a pointer to the descriptor of the superblock.
  they are aligned on 8 byte boundaries, so the lower 8 bytes
  are used to carve out:
     * credits (one less that the lower bound on the available blocks in the
       superblock)
     * ptr the "upper" 58 bits of the word. i.e. the descriptor*.

- a procheap is a thread local heap structure.
     * active
     * Partial  (a descriptor list ??)
     * sc  (a pointer to sizeclass, the parent size class)

- a sizeclass
     * Partial (a descriptor list ??)
     * sz (the blocksize)
     * sbsize (the superblock size)


= Life Cycle of SuperBlocks =

A super block starts out life being allocated and installed as the
active super block on a procheap by MallocFromNewSB. It remains there
until it becomes full, when it is set free (i.e. removed from the
active slot and not placed any where).

Thus free must be responsible for putting it back into play when
blocks are freed.

When a block is freed, and the superblock it belongs to was FULL,
(and thus becomes PARTIAL) the free routine calls:

     HeapPutPartial(desc);

which installs it as desc->heap->Partial, moving the old value to
the front of the desc->heap->sc->Partial linked list.

When MallocFromPartial gets a request, and heap->Partial is not
NULL, it tries to service the request from that superblock, if it
succeeds and the superblock is not FULL as a result, it tries to
install it as the active superblock of heap (this is not guaranteed
to succeed). If heap->Partial is NULL it also tries much the same
thing for the first superblock in the heap->sc->Partial linked list.

So from the looks of this we can get migration when heap->Partial is
NULL, since we just grab a superblock from the sizeclass list.

= Life Cycle of Descriptors =


= Any Other Life Cyles? =
